<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>变量、作用域与内存 | study a</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="Just study a">
    
    <link rel="preload" href="/myBlog/assets/css/0.styles.03bba5f5.css" as="style"><link rel="preload" href="/myBlog/assets/js/app.de836814.js" as="script"><link rel="preload" href="/myBlog/assets/js/2.344231cb.js" as="script"><link rel="preload" href="/myBlog/assets/js/10.00fd63d2.js" as="script"><link rel="prefetch" href="/myBlog/assets/js/11.96a7907c.js"><link rel="prefetch" href="/myBlog/assets/js/12.4d001da7.js"><link rel="prefetch" href="/myBlog/assets/js/13.fdf0f2c3.js"><link rel="prefetch" href="/myBlog/assets/js/3.a969e1d2.js"><link rel="prefetch" href="/myBlog/assets/js/4.b9efb713.js"><link rel="prefetch" href="/myBlog/assets/js/5.752d2d19.js"><link rel="prefetch" href="/myBlog/assets/js/6.ed26af5a.js"><link rel="prefetch" href="/myBlog/assets/js/7.2bddf6c7.js"><link rel="prefetch" href="/myBlog/assets/js/8.26166d0b.js"><link rel="prefetch" href="/myBlog/assets/js/9.5ed73190.js">
    <link rel="stylesheet" href="/myBlog/assets/css/0.styles.03bba5f5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/myBlog/" class="home-link router-link-active"><!----> <span class="site-name">study a</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/myBlog/" aria-current="page" class="sidebar-link">Study a</a></li><li><a href="/myBlog/TypeScript.html" class="sidebar-link">TypeScript</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Http</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Java Script</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/myBlog/JavaScript/01正则表达式.html" class="sidebar-link">正则表达式</a></li><li><a href="/myBlog/JavaScript/02变量.html" class="sidebar-link">变量</a></li><li><a href="/myBlog/JavaScript/03操作符.html" class="sidebar-link">一元操作符</a></li><li><a href="/myBlog/JavaScript/04变量作用域与内存.html" class="active sidebar-link">变量、作用域与内存</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/JavaScript/04变量作用域与内存.html#动态属性" class="sidebar-link">动态属性</a></li><li class="sidebar-sub-header"><a href="/myBlog/JavaScript/04变量作用域与内存.html#上下文和作用域" class="sidebar-link">上下文和作用域</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/JavaScript/04变量作用域与内存.html#let" class="sidebar-link">let</a></li><li class="sidebar-sub-header"><a href="/myBlog/JavaScript/04变量作用域与内存.html#const" class="sidebar-link">const</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/JavaScript/04变量作用域与内存.html#垃圾回收" class="sidebar-link">垃圾回收</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/JavaScript/04变量作用域与内存.html#标记清理" class="sidebar-link">标记清理</a></li><li class="sidebar-sub-header"><a href="/myBlog/JavaScript/04变量作用域与内存.html#标记整理" class="sidebar-link">标记整理</a></li><li class="sidebar-sub-header"><a href="/myBlog/JavaScript/04变量作用域与内存.html#引用计数" class="sidebar-link">引用计数</a></li><li class="sidebar-sub-header"><a href="/myBlog/JavaScript/04变量作用域与内存.html#分代回收" class="sidebar-link">分代回收</a></li><li class="sidebar-sub-header"><a href="/myBlog/JavaScript/04变量作用域与内存.html#性能" class="sidebar-link">性能</a></li><li class="sidebar-sub-header"><a href="/myBlog/JavaScript/04变量作用域与内存.html#内存管理" class="sidebar-link">内存管理</a></li><li class="sidebar-sub-header"><a href="/myBlog/JavaScript/04变量作用域与内存.html#减少垃圾回收" class="sidebar-link">减少垃圾回收</a></li></ul></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="变量、作用域与内存"><a href="#变量、作用域与内存" class="header-anchor">#</a> 变量、作用域与内存</h1> <p>变量可以包含两种不同类型的数据：原始值和引用值。原始值就是最简单的数据，引用值则是由多个值构成的对象。</p> <p>保存原始值的变量是按值访问的，因为我们操作的就是存储在变量中的实际值。</p> <p>引用值是保存在内存的对象。js不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间。在操作对象是，实际上操作的是对该对象的引用而非实际的对象本身。为此，保存引用值的变量是按引用访问的。</p> <h2 id="动态属性"><a href="#动态属性" class="header-anchor">#</a> 动态属性</h2> <p>对于引用值而言，可以随时添加、修改和删除其属性和方法。</p> <p>在通过变量把一个原始值赋值到另一个变量是，原始值会被复制到新变量的位置。</p> <p>复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来。</p> <p>在传递参数上，值会被复制到一个局部变量（即一个命名参数，或者用ECMAScript的话说，就是arguments对象的一个槽位）。如果变量中传递的是对象，就没有那么清楚了，因为对象保存在全局做作用域的堆内存上。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span>
    obj <span class="token operator">=</span> <span class="token punctuation">{</span>
        str<span class="token operator">:</span> <span class="token string">'ok'</span>
    <span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    num <span class="token operator">+=</span> <span class="token number">20</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    obj<span class="token punctuation">.</span>str <span class="token operator">=</span> <span class="token string">'no'</span>
<span class="token punctuation">}</span>
<span class="token comment">//num 不变还为10  obj改变 str变为no</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">typeof</span> <span class="token keyword">null</span> <span class="token comment">//object</span>
<span class="token keyword">typeof</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">//object</span>
<span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">//object</span>
<span class="token comment">//为知道具体是什么类型的对象，需要用到instanceof操作符 instanceof前面必须是一个对象</span>
<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token comment">//报错 因为instanceof前面需要是一个对象，而{}同时也是空代码段，js无法识别为空代码段还是一个对象</span>
<span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">instanceof</span> <span class="token class-name">Object</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Array</span>
<span class="token operator">/</span><span class="token punctuation">.</span><span class="token operator">/</span>g <span class="token keyword">instanceof</span> <span class="token class-name">RegExp</span> 
</code></pre></div><h2 id="上下文和作用域"><a href="#上下文和作用域" class="header-anchor">#</a> 上下文和作用域</h2> <p>变量或函数的上下文决定了他们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象。</p> <p>上下文中的代码在执行的时候，会创建变量对象的一个作用域链。如果上下文是函数，则其活动对象用作变量对象。活动对象最初只有一个定义变量：arguments。作用域链中的下一个变量对象来自包含上下文，在下一个对象来自再下一个包含上下文。以此类推知道全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象。</p> <h3 id="let"><a href="#let" class="header-anchor">#</a> let</h3> <p>let的作用于是块级的，if块、while块、function块，甚至连单独的块也是let声明变量的作用域。、</p> <p>let与var的另一个不同指出是在同一作用域内不能声明两次。重复的var声明会被忽略，而重复的let声明会抛出SyntaxError。</p> <h3 id="const"><a href="#const" class="header-anchor">#</a> const</h3> <p>使用const声明的变量必须同时初始化为某个值，一经声明，在其生命周期的任何时候都不能再重新赋予新值。</p> <p>如果开发流程并不会因此而受到很大的影响，就应该尽可能地多使用const声明，除非确实需要一个将来会重新赋值的变量。这样可以从根本上保证提前发现重新赋值导致的bug。</p> <h2 id="垃圾回收"><a href="#垃圾回收" class="header-anchor">#</a> 垃圾回收</h2> <p>JavaScript是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。JavaScript为开发者卸下了这个负担，通过自动内存管理实现内存分配和闲置资源回收。基本思路很简单：确定哪个变量不会再使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每个一段时间（或者说在代码执行过程中某特预定的收集时间）就会自动运行。由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。垃圾回收过程是一个近似且不完美的方案，因为某块内存在是否还有用，属于“不可判定的”问题，意味着靠算法是解决不了的。</p> <p>我们以函数中局部变量的正常生命周期函数为例。函数中的局部变量会在函数执行时存在。此时栈（或堆）内存会分配空间以保存相应的值。函数在内部使用了变量，然后退出。此时，就不再需要那个局部变量了，它占用的内存可以释放，供后面使用。这种情况下显然不再需要局部变量了，但并不是所有时候都会这么明显。垃圾回收程序必须跟踪记录哪个变量还会使用以及那个变量不会再使用，以便回收内存。如何标记为使用的变量也许有不同的实现方式：标记清理和引用计数</p> <h3 id="标记清理"><a href="#标记清理" class="header-anchor">#</a> 标记清理</h3> <p>在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记，当变量离开上下文时，会被加上离开上下文的标记。</p> <p>给变量加标记的方式有很多种：</p> <ol><li>变量进入上下文时，反转某一位。</li> <li>维护 在上下文中 和 不在上下文中 两个变量列表，可以把变量从一个列表转移到另一个列表。</li></ol> <p>垃圾回收程序运行时，会标记内存中存储的所有变量。它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到他们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有制并收回他们的内存。</p> <p>弊端：因为需要遍历所以肯定会暂用程序执行的时间，可能会导致程序假死。（现在v8引擎已经非常强了，就算使用标记清除也不会占用程序执行时间太长，超不过1秒）</p> <h3 id="标记整理"><a href="#标记整理" class="header-anchor">#</a> 标记整理</h3> <p>在标记清除时，清除数据后会导致清除的空间不再连续，下次存储数据时也是不连续的，所以在标记清除上增加了对内存空间的整理也就是(标记整理），解决了空间碎片化问题，其实就是标记清除的增强版</p> <h3 id="引用计数"><a href="#引用计数" class="header-anchor">#</a> 引用计数</h3> <p>对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为1。如果同一个之又被赋给了另一个变量，那么引用数加1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减1.当一个值的引用数为0时，就说明没办法在访问到这个值了，因此可以安全的回收其内存了。垃圾回收程序下次运行的时候就会释放引用数为0的值的内存。</p> <p>弊端：无法处理循环引用的对象，这是需要标记清除来处理</p> <h3 id="分代回收"><a href="#分代回收" class="header-anchor">#</a> 分代回收</h3> <p>分代回收是将数据分类保存（新生代、老生代），多回收新生代，少回收老生代，减少每次需遍历的对象，从而减少每次GC的耗时。在新生代中经过一次GC后将新生代的数据晋升至老生代。（From和To都是新生代）</p> <p><img src="https://pic2.zhimg.com/80/v2-a34c08fbe480a22b62fa4273ef95c681_720w.png" alt="img"></p> <h3 id="性能"><a href="#性能" class="header-anchor">#</a> 性能</h3> <p>现代垃圾回收程序会基于对JavaScript运行时环境的探测来决定何时运行。探测机制因引擎而异，但基本上都是根据已分配对象的大小和数量来判断的。在一次完整的垃圾回收之后，V8的堆增长策略会根据活跃对象的数量外加一些余量来确定何时再次垃圾回收。</p> <p>某些浏览器中是有可能（但不推荐）主动出发垃圾回收的。</p> <h3 id="内存管理"><a href="#内存管理" class="header-anchor">#</a> 内存管理</h3> <p>优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数据不再必要，那么把它设置为null，从而使放弃引用。这也可以叫做解除引用。</p> <ol><li><p>通过const和let声明提升性能</p> <p>因为const和let都以块（而非函数）为作用于，所以相比用var用这两个新关键字可能会更早地让垃圾回收程序介入，尽快回收应该回收的内存。</p></li> <li><p>隐藏类和删除操作</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Article</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">'this is title'</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">'this is text'</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> a1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Article</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> a2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Article</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

a2<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'person'</span>
<span class="token comment">//V8会将创建的对象与隐藏类关联起来。V8引擎会在后台配置，让这两个实例共享相同的隐藏类，因为这两个实例共享同一个构造函数和原型，但如果后面给a2添加一个author的属性，此时两个Article示例就会对应两个不同的隐藏类。</span>

<span class="token keyword">delete</span> a2<span class="token punctuation">.</span>text
<span class="token comment">//使用delete关键字会导致生成相同的隐藏类片段。即使两个实例使用同一个构造函数，他们也不再共享一个隐藏类。动态删除属性与动态添加属性导致的后果一样。最佳实践是把不想要的属性设置为null。这样可以保持隐藏类不变和继续共享。</span>
</code></pre></div></li> <li><p>内存泄漏</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    name <span class="token operator">=</span> <span class="token string">'Jake'</span>
<span class="token punctuation">}</span>
<span class="token comment">//意外声明全局变量是最常见但也最容易修复的内存泄漏问题</span>

<span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string">'Jake'</span>
<span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>
<span class="token comment">//定时器也可能会悄悄的导致内存泄漏，定时器的回调通过闭包引用了外部变量</span>

<span class="token keyword">let</span> <span class="token function-variable function">outer</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string">'Jake'</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> name
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//使用JavaScript闭包很容易在不知不觉间造成内存泄漏</span>
</code></pre></div></li> <li><p>静态分配与对象池</p> <p>如果能够合理使用分配内存，同时避免多余的垃圾回收，就可以保住因释放内存而损失的性能。</p> <p>浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度。如果有很多对象被初始化，然后一下子有又都超出了作用域，那么浏览器会采用更激进的方式跳读垃圾回收程序运行，这样当然会影响性能。</p></li></ol> <h3 id="减少垃圾回收"><a href="#减少垃圾回收" class="header-anchor">#</a> 减少垃圾回收</h3> <ol><li><p>对象object优化</p> <p>为了最大限度的实现对象的重用，应该像避使用new语句一样来避免使用{}来新建对象。</p> <p>常常使用对象作为方法的返回值会导致过多的内存创建，最好是在每一次函数调用完成之后，将需要返回的数据放入一个全局的对象中，并返回此全局对象。但是这就意味着每一次方法调用都会导致全局对象内容的修改，有可能会导致错误的发生。因此，一定要对全局对象的使用进行详细的注释和说明。</p> <p>有些时候可以清空对象，再添加新属性就可以达到重复利用对象的目的。</p></li> <li><p>数组array优化</p> <p>将[]赋值给一个数组对象，是清空数组的捷径（例如：arr = []）但是需要注意的是，这种方式又创建了一个新的空对象，并且将原来的数组对象变成了一小片内存垃圾。实际上将数组长度赋值为0（arr.length = 0）也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生。</p></li> <li><p>方法function优化</p> <p>关于setTimeout中的匿名方法每次调用都会创建一个新的方法对象，这就会导致了大量的方法对象垃圾。为了解决这个问题，可以把这个方法先作为返回值的方法保存起来。</p></li> <li><p>显然，重写大量的库函数是非常痛苦的，因此你必须仔细权衡方法的易用性和内存垃圾产生情况。如果产生大量内存垃圾的方法在动画的每一帧中被多次调用，你可能就会兴高采烈的重写库函数啦。</p> <p>在递归函数中，通过{}构造空对象，并在递归过程中传递数据，虽然是很方便的。但是更好的方式是：利用一个单独的数组对象作为堆栈，在递归过程中对数组进行push和pop操作。更进一步，不要调用array的pop方法（pop将会使得array的最后一个元素将会变成内存垃圾），而应该使用一个索引来记录数组的最后一个元素的位置，在pop时简单的将索引减一即可；类似的，将索引加1来代替array的push操作，只有当索引对应的元素不存在时，才执行真正的push为数组加入一个新元素。</p> <p>另外，在任何时候，都应该避免使用向量对象（例如：包含x和y属性的vector2对象）。有些方法将向量对象作为方法返回值，既可以支持返回值的再次修改，又能够将需要的属性一次性返回，使用起来非常方便。但是有时候在一帧动画中，创建了成百上千个这样的向量对象，从而导致严重的垃圾回收性能问题，也是非常常见的。因此最好将这些方法分离成具有独立职责的功能个体，例如：利用getX()和getY()方法（返回具体数据）代替getPosition()方法（返回一个vector2对象）。</p></li></ol> <p>参考资料：</p> <p>JavaScript高级程序设计（第4版）</p> <p>https://www.cnblogs.com/zhwl/p/4664604.html</p> <p>https://www.jb51.net/article/75292.htm</p> <p>https://zhuanlan.zhihu.com/p/261419516</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/myBlog/JavaScript/03操作符.html" class="prev">
        一元操作符
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/myBlog/assets/js/app.de836814.js" defer></script><script src="/myBlog/assets/js/2.344231cb.js" defer></script><script src="/myBlog/assets/js/10.00fd63d2.js" defer></script>
  </body>
</html>
